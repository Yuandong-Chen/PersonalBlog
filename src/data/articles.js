let articles = [
  {
    title: "LeetCode 556 Next Greater Element III",
    date: "2019-01-01",
    tags: "LeetCode 556 Next Greater Element III",
    extract: "Use Stack data Structure Easy achieve O(N)",
    data: '<p><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">Given a positive</span></span></span><strong>32-bit</strong><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">integer</span></span></span><strong>n</strong><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">, you need to find the smallest</span></span></span><strong>32-bit</strong><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">integer which has exactly the same digits existing in the integer</span></span></span><strong>n</strong><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">and is greater in value than n. If no such positive</span></span></span><strong>32-bit</strong><span style="color:#000000"><span style="font-size:13px"><span style="background-color:#ffffff">integer exists, you need to return -1.</span></span></span></p><p><strong>Example 1:</strong></p><pre><code><strong>Input:</strong> 12<br/><strong>Output:</strong> 21<br/></code></pre><p style="text-align:start;text-indent:2em;"> </p><p><strong>Example 2:</strong></p><pre><code><strong>Input:</strong> 21<br/><strong>Output:</strong> -1</code></pre><p></p><pre><code>object Solution {<br/> def nextGreaterElement(n: Int): Int = {<br/> val arr: Array[Char] = n.toString.toCharArray<br/> val len = arr.length<br/> <span style="color:#aa0d91">if</span>(len == <span style="color:#1c00cf">0</span>) <span style="color:#aa0d91">return</span> -<span style="color:#1c00cf">1</span><br/> import collection.mutable.Stack<br/> val <span style="color:#aa0d91">q</span>: Array[Int] = Array.fill(len)(-<span style="color:#1c00cf">1</span>)<br/> val stk: Stack[(Int, Int)] = Stack()<br/> stk.push((arr(len - <span style="color:#1c00cf">1</span>), len - <span style="color:#1c00cf">1</span>))<br/> var i = len - <span style="color:#1c00cf">2</span><br/> <span style="color:#aa0d91">while</span>(i &gt;= <span style="color:#1c00cf">0</span>) {<br/> <span style="color:#aa0d91">while</span>(stk.nonEmpty &amp;&amp; stk.top._1 &gt; arr(i)) {<br/> val (<span style="color:#1c00cf">_</span>, ind) = stk.pop()<br/> <span style="color:#aa0d91">if</span>(<span style="color:#c41a16">q(ind)</span> == -<span style="color:#1c00cf">1</span>) {<br/> <span style="color:#c41a16">q(ind)</span> = i<br/> }<br/> }<br/> stk.push((arr(i), i))<br/> i -= <span style="color:#1c00cf">1</span><br/> }<br/> //println(q.toList)<br/> val <span style="color:#aa0d91">m</span> = q.max<br/> <span style="color:#aa0d91">if</span>(<span style="color:#aa0d91">m</span> == -<span style="color:#1c00cf">1</span>) <span style="color:#aa0d91">return</span> -<span style="color:#1c00cf">1</span><br/> var find = q.length - <span style="color:#1c00cf">1</span><br/> var <span style="color:#aa0d91">continue</span> = true<br/> <span style="color:#aa0d91">while</span> (find &gt;= <span style="color:#1c00cf">0</span> &amp;&amp; <span style="color:#aa0d91">continue</span>) {<br/> <span style="color:#aa0d91">if</span>(<span style="color:#c41a16">q(find)</span> == <span style="color:#aa0d91">m</span>) {<br/> <span style="color:#aa0d91">continue</span> = false<br/> }<br/> find -= <span style="color:#1c00cf">1</span><br/> }<br/> find += <span style="color:#1c00cf">1</span><br/> <span style="color:#aa0d91">if</span>(find == -<span style="color:#1c00cf">1</span>) <span style="color:#aa0d91">return</span> -<span style="color:#1c00cf">1</span><br/> val t = arr(find)<br/> arr(find) = arr(<span style="color:#c41a16">q(find)</span>)<br/> arr(<span style="color:#c41a16">q(find)</span>) = t<br/> try {<br/> (arr.take(<span style="color:#c41a16">q(find)</span> + <span style="color:#1c00cf">1</span>) ++ arr.drop(<span style="color:#c41a16">q(find)</span> + <span style="color:#1c00cf">1</span>).sorted).foldLeft(<span style="color:#c41a16">&quot;&quot;</span>)(<span style="color:#1c00cf">_</span> + <span style="color:#1c00cf">_</span>).toInt<br/> }<br/> catch {<br/> case <span style="color:#1c00cf">_</span>: <span style="color:#c41a16">Throwable =&gt;</span> -<span style="color:#1c00cf">1</span><br/> }<br/> }<br/>}</code></pre>',
    _rating: 0,
    _vector: null
  },
  {
    title: "LeetCode 503 Next Greater Element II",
    date: "2019-01-02",
    tags: "LeetCode 503 Next Greater Element II",
    extract: "Solve cyclic array using Stack",
    data: '<p style="text-align:start;text-indent:2em;">Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#x27;t exist, output -1 for this number.</p><p></p><p style="text-align:start;text-indent:2em;"><strong>Example 1:</strong><br/></p><pre><code><strong>Input:</strong> [1,2,1]<br/><strong>Output:</strong> [2,-1,2]<br/><strong>Explanation:</strong> The first 1&#x27;s next greater number is 2; <br/>The number 2 can&#x27;t find next greater number; <br/>The second 1&#x27;s next greater number needs to search circularly, which is also 2.<br/></code></pre><p style="text-align:start;text-indent:2em;"><strong>Note:</strong> The length of given array won&#x27;t exceed 10000.</p><p></p><pre><code>object Solution {<br/> def nextGreaterElements(nums: <span style="color:#5c2699">Array</span>[<span style="color:#5c2699">Int</span>]): <span style="color:#5c2699">Array</span>[<span style="color:#5c2699">Int</span>] = {<br/> import collection.mutable.Stack<br/> val stk: Stack[(<span style="color:#5c2699">Int</span>, <span style="color:#5c2699">Int</span>)] = Stack()<br/> val <span style="color:#5c2699">len</span> = nums.length<br/> <span style="color:#aa0d91">if</span>(<span style="color:#5c2699">len</span> == <span style="color:#1c00cf">0</span>) return <span style="color:#5c2699">Array</span>()<br/> val q: <span style="color:#5c2699">Array</span>[<span style="color:#5c2699">Int</span>] = <span style="color:#5c2699">Array</span>.fill(<span style="color:#5c2699">len</span>)(<span style="color:#1c00cf">-1</span>)<br/> var i = <span style="color:#1c00cf">1</span><br/> stk.push((nums(<span style="color:#1c00cf">0</span>), <span style="color:#1c00cf">0</span>))<br/> <span style="color:#aa0d91">while</span>(i &lt; <span style="color:#1c00cf">2</span> * <span style="color:#5c2699">len</span>) {<br/> <span style="color:#aa0d91">while</span> (stk.nonEmpty &amp;&amp; stk.top._1 &lt; nums(i % <span style="color:#5c2699">len</span>)) {<br/> val (_, ind) = stk.pop()<br/> <span style="color:#aa0d91">if</span>(q(ind) == <span style="color:#1c00cf">-1</span>) {<br/> q(ind) = nums(i % <span style="color:#5c2699">len</span>)<br/> }<br/> }<br/> stk.push((nums(i % <span style="color:#5c2699">len</span>), i % <span style="color:#5c2699">len</span>))<br/> i += <span style="color:#1c00cf">1</span><br/> }<br/> q<br/> }<br/>}</code></pre>',
    _rating: 0,
    _vector: null
  },
  {
    title: "LeetCode 496 Next Greater Element I",
    date: "2019-01-03",
    tags: "LeetCode 496 Next Greater Element I",
    extract: "Solve dinstinct condition next greater problem",
    data: '<p style="text-align:start;text-indent:2em;">You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>â€™s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>&#x27;s elements in the corresponding places of <code>nums2</code>. </p><p style="text-align:start;text-indent:2em;">The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p><p style="text-align:start;text-indent:2em;"><strong>Example 1:</strong><br/></p><pre><code><strong>Input:</strong> <strong>nums1</strong> = [4,1,2], <strong>nums2</strong> = [1,3,4,2].<br/><strong>Output:</strong> [-1,3,-1]<br/><strong>Explanation:</strong><br/> For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br/> For number 1 in the first array, the next greater number for it in the second array is 3.<br/> For number 2 in the first array, there is no next greater number for it in the second array, so output -1.<br/></code></pre><p style="text-align:start;text-indent:2em;"></p><p style="text-align:start;text-indent:2em;"><strong>Example 2:</strong><br/></p><pre><code><strong>Input:</strong> <strong>nums1</strong> = [2,4], <strong>nums2</strong> = [1,2,3,4].<br/><strong>Output:</strong> [3,-1]<br/><strong>Explanation:</strong><br/> For number 2 in the first array, the next greater number for it in the second array is 3.<br/> For number 4 in the first array, there is no next greater number for it in the second array, so output -1.<br/></code></pre><p style="text-align:start;text-indent:2em;"></p><p style="text-align:start;text-indent:2em;"><strong>Note:</strong><br/></p><ol><li>All elements in <code>nums1</code> and <code>nums2</code> are unique.</li><li>The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li></ol><pre><code><span style="color:#aa0d91">object</span> Solution {<br/> def nextGreaterElement(nums1: Array[<span style="color:#5c2699">Int</span>], nums2: Array[<span style="color:#5c2699">Int</span>]): Array[<span style="color:#5c2699">Int</span>] = {<br/> <span style="color:#aa0d91">import</span> collection.mutable.{Map, Stack}<br/> <span style="color:#aa0d91">val</span> q: Map[<span style="color:#5c2699">Int</span>, <span style="color:#5c2699">Int</span>] = Map().withDefaultValue(-<span style="color:#1c00cf">1</span>)<br/> <span style="color:#aa0d91">val</span> stk: Stack[<span style="color:#5c2699">Int</span>] = Stack()<br/> <span style="color:#aa0d91">val</span> len = nums2.length<br/> <span style="color:#aa0d91">if</span>(len == <span style="color:#1c00cf">0</span>) <span style="color:#aa0d91">return</span> Array()<br/> stk.push(nums2(<span style="color:#1c00cf">0</span>))<br/> <span style="color:#aa0d91">var</span> i = <span style="color:#1c00cf">1</span><br/> <span style="color:#aa0d91">while</span>(i &lt; len) {<br/> <span style="color:#aa0d91">while</span>(stk.nonEmpty &amp;&amp; stk.top &lt; nums2(i)) {<br/> <span style="color:#aa0d91">val</span> j = stk.pop()<br/> q(j) = nums2(i)<br/> }<br/> stk.push(nums2(i))<br/> i += <span style="color:#1c00cf">1</span><br/> }<br/> <br/> <span style="color:#aa0d91">for</span> {<br/> i &lt;- nums1<br/> } yield q(i)<br/> }<br/>}</code></pre>',
    _rating: 0,
    _vector: null
  },
  {
    title: "LeetCode 743 Network Delay Time",
    date: "2019-01-04",
    tags: "LeetCode 743 Network Delay Time",
    extract: "Dijkstra Algorithm",
    data: '<p style="text-align:start;text-indent:2em;">There are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.</p><p style="text-align:start;text-indent:2em;">Given <code>times</code>, a list of travel times as <strong>directed</strong> edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.</p><p style="text-align:start;text-indent:2em;">Now, we send a signal from a certain node <code>K</code>. How long will it take for all nodes to receive the signal? If it is impossible, return <code>-1</code>.</p><p style="text-align:start;text-indent:2em;"><strong>Note:</strong></p><ol><li><code>N</code> will be in the range <code>[1, 100]</code>.</li><li><code>K</code> will be in the range <code>[1, N]</code>.</li><li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li><li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 &lt;= u, v &lt;= N</code> and <code>1 &lt;= w &lt;= 100</code>.</li></ol><pre><code><span style="color:#aa0d91">object</span> Solution {<br/> def networkDelayTime(times: Array[Array[<span style="color:#5c2699">Int</span>]], N: <span style="color:#5c2699">Int</span>, K: <span style="color:#5c2699">Int</span>): <span style="color:#5c2699">Int</span> = {<br/> <span style="color:#aa0d91">import</span> collection.mutable.Map<br/> <span style="color:#aa0d91">var</span> graph: Map[<span style="color:#5c2699">Int</span>, Map[<span style="color:#5c2699">Int</span>, <span style="color:#5c2699">Int</span>]] = Map().withDefaultValue(<span style="color:#aa0d91">null</span>)<br/> <span style="color:#aa0d91">for</span> {<br/> Array(u, v, w) &lt;- times<br/> } {<br/> <span style="color:#aa0d91">if</span>(graph(u) == <span style="color:#aa0d91">null</span>) {<br/> graph(u) = Map(v -&gt; w)<br/> }<br/> <span style="color:#aa0d91">else</span> {<br/> graph(u)(v) = w<br/> }<br/> }<br/> <span style="color:#aa0d91">val</span> seen = Array.fill(N)(<span style="color:#aa0d91">false</span>)<br/> <span style="color:#aa0d91">val</span> dis = Array.fill(N)(<span style="color:#5c2699">Int</span>.MaxValue)<br/> <span style="color:#aa0d91">for</span> {<br/> i &lt;- <span style="color:#1c00cf">0</span> until N<br/> } {<br/> dis(i) = <span style="color:#5c2699">Int</span>.MaxValue<br/> }<br/> seen(K - <span style="color:#1c00cf">1</span>) = <span style="color:#aa0d91">true</span><br/> dis(K - <span style="color:#1c00cf">1</span>) = <span style="color:#1c00cf">0</span><br/> <span style="color:#aa0d91">if</span>(graph(K) != <span style="color:#aa0d91">null</span>) {<br/> <span style="color:#aa0d91">for</span> {<br/> (v, w) &lt;- graph(K).toArray<br/> } {<br/> dis(v - <span style="color:#1c00cf">1</span>) = w<br/> }<br/> }<br/> <span style="color:#aa0d91">else</span> {<br/> <span style="color:#aa0d91">if</span>(N == <span style="color:#1c00cf">1</span>) <span style="color:#aa0d91">return</span> <span style="color:#1c00cf">0</span><br/> <span style="color:#aa0d91">return</span> -<span style="color:#1c00cf">1</span><br/> }<br/> <span style="color:#aa0d91">var</span> <span style="color:#aa0d91">continue</span> = <span style="color:#aa0d91">true</span><br/> <span style="color:#aa0d91">while</span>(<span style="color:#aa0d91">continue</span>) {<br/> <span style="color:#aa0d91">var</span> shortestP = -<span style="color:#1c00cf">1</span><br/> <span style="color:#aa0d91">var</span> shortestDis = <span style="color:#5c2699">Int</span>.MaxValue<br/> <span style="color:#aa0d91">for</span> {<br/> (b, ind) &lt;- seen.zipWithIndex <span style="color:#aa0d91">if</span> !b<br/> } {<br/> <span style="color:#aa0d91">if</span>(dis(ind) &lt; shortestDis) {<br/> shortestP = ind + <span style="color:#1c00cf">1</span><br/> shortestDis = dis(ind)<br/> }<br/> }<br/> <span style="color:#aa0d91">if</span>(shortestP == -<span style="color:#1c00cf">1</span>) {<br/> <span style="color:#aa0d91">continue</span> = <span style="color:#aa0d91">false</span><br/> }<br/> <span style="color:#aa0d91">else</span> {<br/> seen(shortestP - <span style="color:#1c00cf">1</span>) = <span style="color:#aa0d91">true</span><br/> dis(shortestP - <span style="color:#1c00cf">1</span>) = shortestDis<br/> <span style="color:#aa0d91">if</span>(graph(shortestP) != <span style="color:#aa0d91">null</span>) {<br/> <span style="color:#aa0d91">for</span> {<br/> (u, w) &lt;- graph(shortestP).toArray<br/> } {<br/> dis(u - <span style="color:#1c00cf">1</span>) = Math.min(dis(u - <span style="color:#1c00cf">1</span>), shortestDis + w)<br/> }<br/> }<br/> }<br/> }<br/> <span style="color:#aa0d91">val</span> ans = dis.max<br/> <span style="color:#aa0d91">if</span>(ans == <span style="color:#5c2699">Int</span>.MaxValue) <span style="color:#aa0d91">return</span> -<span style="color:#1c00cf">1</span><br/> ans<br/> }<br/>}</code></pre>',
    _rating: 0,
    _vector: null
  },
  {
    title: "LeetCode 600 Non-negative Integers without Consecutive Ones",
    date: "2019-01-05",
    tags: "LeetCode 600 Non-negative Integers without Consecutive Ones",
    extract: "Fibonacci DP Problem",
    data: '<p style="text-align:start;text-indent:2em;">Given a positive integer n, find the number of <strong>non-negative</strong> integers less than or equal to n, whose binary representations do NOT contain <strong>consecutive ones</strong>.</p><p style="text-align:start;text-indent:2em;"><strong>Example 1:</strong><br/></p><pre><code><strong>Input:</strong> 5<br/><strong>Output:</strong> 5<br/><strong>Explanation:</strong> <br/>Here are the non-negative integers &lt;= 5 with their corresponding binary representations:<br/>0 : 0<br/>1 : 1<br/>2 : 10<br/>3 : 11<br/>4 : 100<br/>5 : 101<br/>Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. <br/></code></pre><p style="text-align:start;text-indent:2em;"></p><p style="text-align:start;text-indent:2em;"><strong>Note:</strong> 1 &lt;= n &lt;= 10<sup>9</sup></p><pre><code>object Solution {<br/> val dp: Array[Int] = Array.fill(<span style="color:#1c00cf">32</span>)(<span style="color:#1c00cf">0</span>)<br/> dp(<span style="color:#1c00cf">0</span>) = <span style="color:#1c00cf">1</span><br/> dp(<span style="color:#1c00cf">1</span>) = <span style="color:#1c00cf">2</span><br/> <span style="color:#aa0d91">for</span> {<br/> i &lt;- <span style="color:#1c00cf">2</span> to <span style="color:#1c00cf">31</span><br/> } {<br/> dp(i) = dp(i - <span style="color:#1c00cf">1</span>) + dp(i - <span style="color:#1c00cf">2</span>)<br/> }<br/> def findIntegers(num: Int): Int = {<br/> var ans = <span style="color:#1c00cf">0</span><br/> val arr: Array[Int] = num.toBinaryString.toCharArray.map(_ - <span style="color:#c41a16">&#x27;0&#x27;</span>)<br/> var i = <span style="color:#1c00cf">0</span><br/> val len = arr.length<br/> var preOne = <span style="color:#aa0d91">false</span><br/> var <span style="color:#aa0d91">continue</span> = <span style="color:#aa0d91">true</span><br/> <span style="color:#aa0d91">while</span>(i &lt; len &amp;&amp; <span style="color:#aa0d91">continue</span>) {<br/> <span style="color:#aa0d91">if</span>(arr(i) == <span style="color:#1c00cf">1</span>) {<br/> <span style="color:#aa0d91">if</span>(preOne) {<br/> ans += dp(len - i - <span style="color:#1c00cf">1</span>)<br/> <span style="color:#aa0d91">continue</span> = <span style="color:#aa0d91">false</span><br/> }<br/> <span style="color:#aa0d91">else</span> {<br/> ans += dp(len - i - <span style="color:#1c00cf">1</span>)<br/> preOne = <span style="color:#aa0d91">true</span><br/> }<br/> }<br/> <span style="color:#aa0d91">else</span> {<br/> preOne = <span style="color:#aa0d91">false</span><br/> }<br/> i += <span style="color:#1c00cf">1</span><br/> }<br/> <span style="color:#aa0d91">if</span>(i == len &amp;&amp; <span style="color:#aa0d91">continue</span>) {<br/> ans += <span style="color:#1c00cf">1</span><br/> }<br/> ans<br/> }<br/>}</code></pre>',
    _rating: 0,
    _vector: null
  }
];

export default articles;
